Testing in Spring boot with Scala tests

Spring boot tests provides great support for testing which combined with the sugar syntax form scala tests makes testing more pleasant and less verbose.

Please find all the code used in this post in github (https://github.com/ignacioSuay/spring-scala-tests)

## Dependencies

We will need to add the following dependencies to our project:Spring boot, Scala and ScalaTests,

As the ScalaTest documentation(http://www.scalatest.org/user_guide/using_the_scalatest_maven_plugin) recommends we should disable the surefire plugin.

I am building this project with Maven so the pom.xml file looks like:

[add pom.xml]

## Sample Controller and service

In order to have a controller to test, I need to create a simple Customer Rest controller which which given a customer id calls findCustomer in the CustomerService.

Here is the CustomerController:

[add code]

And the CustomerService:

[add code]

## Unit testing the controller with @WebMvcTest

The first that we want to test is the Controller in isolation.

As you can see in the CustomerController, this class has a dependency to the CustomerService.
For the unit test we are going to mock the CustomerService using the @MockBean annotation provided by Spring.

Spring provides the @WebMvcTest annotation which is very useful when you are only interested in instantiating the web layer and not the whole Spring context.
This annotation will only load configuration relevant to MVC tests (@Controller, @RestController., @ControllerAdvice...) but will disable full auto-configuration (@Component, @Service or @Repository won't be instantiated).

Here are the steps that I followed:

1. Annotate the class with: @RunWith(classOf[SpringRunner]) and @WebMvcTest(Array(classOf[CustomerControler]))

2. Autowired MockMvc. Note that @WebMvcTest auto-configures MockMvc without needing to start a web container.By default, @WebMvcTest loads all the controllers but in this case I am just interested in loading 1 controller (CustomerController), so I add  the name of the controller to the annotation.

3. Mock the customer service. Due to the fact that @WebMvcTest doesn't load any @Service configuration, we need to mock the CustomerService by using the @MockBean annotation.

4. Load the application context by defining a TestContextManager instance. TestContextManager is the main entry point into the Spring TestContext Framework, which provides support for loading and accessing application contexts, dependency injection of test instances, transactional execution of test methods, etc.


## Integration testing with SpringBootTests

In this section, we will go over creating an integration test using SpringBootTest and TestRestTemplate.

TestRestTemplate is a convenient alternative of RestTemplate that is suitable for integration tests

The difference between SpringBootTest and WebMvcTest is that SpringBootTest will start your full application context and the application server (like tomcat).
 While WebMvcTest will only scan you have defined and therefore it is much faster.

1) Annotate the test class with:  @RunWith(classOf[SpringRunner]) and @SpringBootTest(webEnvironment = RANDOM_PORT).
As you can see in the annotation we will start the Tomcat application server using a random port.

2) Autowired a TestRestTemplate class

3) Because we are starting tomcat using a random port we need to inject the port using the @LocalServerPort annotation.

4) Now we can build the url using the random port value.

5) Create your test and test the endpoint using testRestTemplate.
In this case, I am using the getForEntity method which retrieves a Customer by doing a GET request on the specified URL.


## Summary

In this post, we implemented a unit test and an integration test using Spring boot and Scala Tests.
I personally find writing tests with Java to verbose and I like the sugar syntax that other languages like Scala, Groovy or Kotlin provide.

One of the main reasons, I prefer to use any other JVM language is because allows me to create fixture with named and default parameters.

For instance, I could create a fixture for my customer like:

object CustomerFixture {

  def aCustomer(id: Long = 1, name: String = "Bob") = new Customer(id, name)

}

which then I could use in any of my tests like:
aCustomer() -> which will use the default values (id = 1 and name = 100)
aCustomer(name= "Mike") -> which will have id 1 and name Mike
aCustomer(100, "Mike") -> which will result in id 100 and name Mike
















